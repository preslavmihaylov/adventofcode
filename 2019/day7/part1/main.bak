package main

import (
	"fmt"
	"math"
)

const maxArguments = 3

// OpCode ...
type OpCode int

// opcodes
const (
	OpAdd         OpCode = 1
	OpMultiply           = 2
	OpInput              = 3
	OpOutput             = 4
	OpJumpIfTrue         = 5
	OpJumpIfFalse        = 6
	OpLessThan           = 7
	OpEquals             = 8
	OpHalt               = 99
)

// PosMode ...
type PosMode int

// pos modes
const (
	PosModeAddress PosMode = 0
	PosModeValue           = 1
)

func newCommand(inst int) *command {
	cmd := command{}
	cmd.opcode = OpCode(inst % 100)
	inst /= 100

	for i := 0; i < maxArguments; i++ {
		cmd.posModes = append(cmd.posModes, PosMode(inst%10))
		inst /= 10
	}

	return &cmd
}

type command struct {
	opcode   OpCode
	posModes []PosMode
}

func (c *command) instructionSize() int {
	if c.opcode == OpInput || c.opcode == OpOutput {
		return 2
	} else if c.opcode == OpJumpIfTrue || c.opcode == OpJumpIfFalse {
		return 3
	}

	return 4
}

type program struct {
	instructions []int
	instPtr      int
	output       int
}

func main() {
	maxOutput := 0
	for a := 5; a < 10; a++ {
		for b := 5; b < 10; b++ {
			for c := 5; c < 10; c++ {
				for d := 5; d < 10; d++ {
					for e := 5; e < 10; e++ {
						if a == b || a == c || a == d || a == e ||
							b == c || b == d || b == e ||
							c == d || c == e ||
							d == e {
							continue
						}

						dupProgram1 := make([]int, len(initProgram))
						dupProgram2 := make([]int, len(initProgram))
						dupProgram3 := make([]int, len(initProgram))
						dupProgram4 := make([]int, len(initProgram))
						dupProgram5 := make([]int, len(initProgram))

						copy(dupProgram1, initProgram)
						copy(dupProgram2, initProgram)
						copy(dupProgram3, initProgram)
						copy(dupProgram4, initProgram)
						copy(dupProgram5, initProgram)

						ip1 := 0
						ip2 := 0
						ip3 := 0
						ip4 := 0
						ip5 := 0
						output1 := 0
						output2 := 0
						output3 := 0
						output4 := 0
						output5 := 0

						halted := false
						for !halted {
							output1, ip1, _ = run(dupProgram1, ip1, output1, []int{a, output5})
							output2, ip2, _ = run(dupProgram2, ip2, output2, []int{b, output1})
							output3, ip3, _ = run(dupProgram3, ip3, output3, []int{c, output2})
							output4, ip4, _ = run(dupProgram4, ip4, output4, []int{d, output3})
							output5, ip5, halted = run(dupProgram5, ip5, output5, []int{e, output4})
						}

						if maxOutput < output5 {
							maxOutput = output5
						}
					}
				}
			}
		}
	}

	fmt.Println(maxOutput)
}

func run(program []int, beginInstPtr int, lastOutput int, inputs []int) (int, int, bool) {
	instPtr := beginInstPtr
	inputIndex := 0
	if beginInstPtr != 0 {
		inputIndex = 1
	}

	result := math.MaxInt32
	for {
		if result != math.MaxInt32 {
			return result, instPtr, false
		}

		cmd := newCommand(program[instPtr])

		didJump := false
		switch cmd.opcode {
		case OpAdd:
			in1 := getValue(program, program[instPtr+1], cmd.posModes[0])
			in2 := getValue(program, program[instPtr+2], cmd.posModes[1])
			outputAddr := program[instPtr+3]

			program[outputAddr] = in1 + in2
		case OpMultiply:
			in1 := getValue(program, program[instPtr+1], cmd.posModes[0])
			in2 := getValue(program, program[instPtr+2], cmd.posModes[1])
			outputAddr := program[instPtr+3]

			program[outputAddr] = in1 * in2
		case OpInput:
			val := inputs[inputIndex]
			inputIndex++

			outputAddr := program[instPtr+1]

			program[outputAddr] = val

		case OpOutput:
			in1 := getValue(program, program[instPtr+1], PosModeAddress)

			result = in1
		case OpJumpIfTrue:
			in1 := getValue(program, program[instPtr+1], cmd.posModes[0])
			in2 := getValue(program, program[instPtr+2], cmd.posModes[1])

			if in1 != 0 {
				didJump = true
				instPtr = in2
			}
		case OpJumpIfFalse:
			in1 := getValue(program, program[instPtr+1], cmd.posModes[0])

			in2 := getValue(program, program[instPtr+2], cmd.posModes[1])

			if in1 == 0 {
				didJump = true
				instPtr = in2
			}
		case OpLessThan:
			in1 := getValue(program, program[instPtr+1], cmd.posModes[0])
			in2 := getValue(program, program[instPtr+2], cmd.posModes[1])
			outputAddr := program[instPtr+3]

			if in1 < in2 {
				program[outputAddr] = 1
			} else {
				program[outputAddr] = 0
			}
		case OpEquals:
			in1 := getValue(program, program[instPtr+1], cmd.posModes[0])
			in2 := getValue(program, program[instPtr+2], cmd.posModes[1])
			outputAddr := program[instPtr+3]

			if in1 == in2 {
				program[outputAddr] = 1
			} else {
				program[outputAddr] = 0
			}
		case OpHalt:
			return lastOutput, 0, true
		default:
			panic(fmt.Sprintf("unrecognized opcode: %d", cmd.opcode))
		}

		if !didJump {
			instPtr += cmd.instructionSize()
		}
	}
}

func getValue(program []int, param int, posMode PosMode) int {
	var res int
	if posMode == PosModeAddress {
		res = program[param]
	} else {
		res = param
	}

	return res
}

var initProgram = []int{
	3, 8, 1001, 8, 10, 8, 105, 1, 0, 0, 21, 38, 47, 64, 85, 106, 187, 268, 349, 430, 99999, 3, 9, 1002, 9, 4, 9, 1001, 9, 4, 9, 1002, 9, 4, 9, 4, 9, 99, 3, 9, 1002, 9, 4, 9, 4, 9, 99, 3, 9, 1001, 9, 3, 9, 102, 5, 9, 9, 1001, 9, 5, 9, 4, 9, 99, 3, 9, 101, 3, 9, 9, 102, 5, 9, 9, 1001, 9, 4, 9, 102, 4, 9, 9, 4, 9, 99, 3, 9, 1002, 9, 3, 9, 101, 2, 9, 9, 102, 4, 9, 9, 101, 2, 9, 9, 4, 9, 99, 3, 9, 1002, 9, 2, 9, 4, 9, 3, 9, 102, 2, 9, 9, 4, 9, 3, 9, 1001, 9, 2, 9, 4, 9, 3, 9, 1001, 9, 1, 9, 4, 9, 3, 9, 101, 1, 9, 9, 4, 9, 3, 9, 102, 2, 9, 9, 4, 9, 3, 9, 101, 2, 9, 9, 4, 9, 3, 9, 102, 2, 9, 9, 4, 9, 3, 9, 1002, 9, 2, 9, 4, 9, 3, 9, 1002, 9, 2, 9, 4, 9, 99, 3, 9, 102, 2, 9, 9, 4, 9, 3, 9, 1002, 9, 2, 9, 4, 9, 3, 9, 1001, 9, 1, 9, 4, 9, 3, 9, 1002, 9, 2, 9, 4, 9, 3, 9, 101, 1, 9, 9, 4, 9, 3, 9, 1002, 9, 2, 9, 4, 9, 3, 9, 1001, 9, 2, 9, 4, 9, 3, 9, 1001, 9, 1, 9, 4, 9, 3, 9, 101, 2, 9, 9, 4, 9, 3, 9, 101, 1, 9, 9, 4, 9, 99, 3, 9, 102, 2, 9, 9, 4, 9, 3, 9, 102, 2, 9, 9, 4, 9, 3, 9, 1001, 9, 1, 9, 4, 9, 3, 9, 1002, 9, 2, 9, 4, 9, 3, 9, 102, 2, 9, 9, 4, 9, 3, 9, 1002, 9, 2, 9, 4, 9, 3, 9, 101, 1, 9, 9, 4, 9, 3, 9, 101, 1, 9, 9, 4, 9, 3, 9, 101, 1, 9, 9, 4, 9, 3, 9, 1002, 9, 2, 9, 4, 9, 99, 3, 9, 1002, 9, 2, 9, 4, 9, 3, 9, 102, 2, 9, 9, 4, 9, 3, 9, 101, 1, 9, 9, 4, 9, 3, 9, 1001, 9, 1, 9, 4, 9, 3, 9, 1002, 9, 2, 9, 4, 9, 3, 9, 102, 2, 9, 9, 4, 9, 3, 9, 102, 2, 9, 9, 4, 9, 3, 9, 101, 2, 9, 9, 4, 9, 3, 9, 102, 2, 9, 9, 4, 9, 3, 9, 1002, 9, 2, 9, 4, 9, 99, 3, 9, 1002, 9, 2, 9, 4, 9, 3, 9, 101, 1, 9, 9, 4, 9, 3, 9, 102, 2, 9, 9, 4, 9, 3, 9, 1001, 9, 2, 9, 4, 9, 3, 9, 1002, 9, 2, 9, 4, 9, 3, 9, 1002, 9, 2, 9, 4, 9, 3, 9, 1001, 9, 1, 9, 4, 9, 3, 9, 1002, 9, 2, 9, 4, 9, 3, 9, 1001, 9, 1, 9, 4, 9, 3, 9, 102, 2, 9, 9, 4, 9, 99,
}
